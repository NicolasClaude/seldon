/*! \file eigenvalue.dox
    \brief Eigenvalue Solvers.
*/

/*!
\page eigenvalue Eigenvalue Solvers

<p>%Seldon is interfaced with libraries performing the research of eigenvalues and eigenvectors of very large sparse linear systems : <b><a href="http://www.caam.rice.edu/software/ARPACK/">Arpack</a></b> and <b><a href="http://trilinos.sandia.gov/packages/anasazi/">Anasazi</a></b>. An example file is located in test/program/eigenvalue_test.cpp. For an efficient computation, the user should compile with one of the direct solvers interfaced by Seldon (ie. Mumps, Pastix, SuperLU or UmfPack). For example, if you are compiling with SuperLU and Arpack, you have to type. </p>

<pre class="fragment">g++ -DSELDON_WITH_SUPERLU -DSELDON_WITH_ARPACK eigenvalue_test.cpp -ISuperLUdir/SRC -LSuperLUdir -lsuperlu -LArpackdir -larpack </pre>

<p>where <b>Arpackdir</b> denotes the directory where Arpack has been installed. </p>


<h2>Syntax</h2>


<p>The syntax of all eigenvalue solvers is similar </p>


<pre class="syntax-box">
void GetEigenvaluesEigenvectors(EigenPb&amp;, Vector&amp; lambda, Vector&amp; lambda_imag, Matrix&amp; eigen_vec);
</pre>


<p>The interface has been done only for double precision (real or complex numbers),
 since single precision is not accurate enough when seeking eigenvalues of very large sparse linear systems.</p>


<h2>Basic use</h2>


<p> We provide an example of eigenvalue resolution with a sparse matrix.</p>


\precode
// first we construct a sparse matrix
int n = 1000; // size of linear system
// we assume that you will construct A correctly
Matrix<double, General, ArrayRowSparse> A(n, n);
// if A is symmetric, prefer a symmetric storage
// so that dsaupd routine will be called (more efficient)

// then we declare the eigenproblem K x = lambda M x
// where K is the stiffness matrix, and M mass matrix
// the syntax is SparseEigenProblem<T, MatrixStiff> 
// where T is double or complex<double>
// and MatrixStiff the type of the stiffness matrix K
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;

// SparseEigenProblem is devoted to the research of eigenvalues for sparse
// matrices (using Seldon format). If you want to consider dense matrices
// you can DenseEigenProblem<T, Prop, Storage> var_eig;
// If you have your own class of Matrix (in which only matrix vector product
// has been defined), use MatrixFreeEigenProblem<T, MatStiff> var_eig;
// where MatStiff is the type of the stiffness matrix

// standard eigenvalue problem => K = A, and M = I
var_eig.InitMatrix(A);

// setting parameters of eigenproblem
var_eig.SetStoppingCriterion(1e-12);
var_eig.SetNbAskedEigenvalues(10);
// you can ask largest eigenvalues of M^-1 K, smallest 
// or eigenvalues closest to a shift sigma
var_eig.SetTypeSpectrum(var_eig.LARGE_EIGENVALUES, 0);
// for small eigenvalues
var_eig.SetTypeSpectrum(var_eig.SMALL_EIGENVALUES, 0);
// eigenvalues clustered around a shift sigma :
double sigma = 0.5;
var_eig.SetTypeSpectrum(var_eig.CENTERED_EIGENVALUES, sigma);

// then you select the computation mode
// REGULAR => you only need of matrix vector product K x (if M = I)
// SHIFTED => the matrix (K - sigma M) will be factorized by
//            using an available direct solver
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);

// declaring arrays that will contains eigenvalues and eigenvectors
Vector<double> lambda, lambda_imag;
Matrix<double> eigen_vec;
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);


// for a generalized eigenvalue problem, you provide both K and M
// default type of M is Matrix<double, Symmetric, ArrayRowSymSparse>
Matrix<double, Symmetric, ArrayRowSymSparse> M(n, n);
Matrix<double, General, ArrayRowSparse> K(n, n);

var_eig.InitMatrix(K, M);

// then you can compute eigenvalues as usual
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// you can also give a specific type for mass Matrix :
SparseEigenProblem<double, Matrix<double, General, RowSparse>, Matrix<double, Symmetric, RowSymSparse> > var_eig2;

// then perform the same operations on var_eig2

\endprecode


<h2>Advanced use</h2>


<p> It may sometimes be useful to compute eigenvalues by writing only a matrix-vector product. It could happen when the stiffness matrix is not effectively stored, and you wish to know large or small eigenvalues of this matrix with only this matrix-vector product. Here an example how to do that : </p>


\precode


// basic class defining a matrix
// we take here the discretization of 1-D laplacien
// with second-order finite difference method
template<class T>
class Matrix_Laplacian1D
{
protected :
  int n;
  double L;
  
public :
  double dx;
  
  // this method is mandatory
  int GetM() const
  {
    return n;
  }

  // this method is mandatory
  int GetN() const
  {
    return n;
  }

  //  this method is not needed, it is placed here
  // to initializa attributes of this specific class
  void Init(int n_, double L_)
  {
    n = n_;
    L = L_;
    dx = L/(n+1);
  }
  
};

// matrix vector product Y = A*X
// mandatory function and main function
template<class T1, class T2, class T3>
void Mlt(const Matrix_Laplacian1D<T1>& A,
         const Vector<T2>& X, Vector<T3>& Y)
{
  int n = A.GetM();
  Y(0) = 2.0*X(0) - X(1);
  Y(n-1) = 2.0*X(n-1) - X(n-2);
  for (int i = 1; i < n-1; i++)
    Y(i) = 2.0*X(i) - X(i-1) - X(i+1);
  
  Mlt(1.0/(A.dx*A.dx), Y);
}


// returns true if the matrix is complex
// mandatory function
template<class T>
bool IsComplexMatrix(const Matrix_Laplacian1D<T>& A)
{
  return false;
}


// returns true if the matrix is symmetric
// mandatory function so that eigensolver knows if the matrix is symmetric or not
template<class T>
bool IsSymmetricMatrix(const Matrix_Laplacian1D<T>& A)
{
  return true;
}


int main()
{
    // testing matrix-free class (defined by the user)
    Matrix_Laplacian1D<double> K;
    K.Init(200, 2.0);
    
    // setting eigenvalue problem
    MatrixFreeEigenProblem<double, Matrix_Laplacian1D<double> > var_eig;
    var_eig.SetStoppingCriterion(1e-12);
    var_eig.SetNbAskedEigenvalues(5);
    var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
    var_eig.SetTypeSpectrum(var_eig.SMALL_EIGENVALUES, 0, var_eig.SORTED_MODULUS);

    // finding large eigenvalues of K
    var_eig.InitMatrix(K);
    Vector<double> lambda, lambda_imag;
    Matrix<double, General, ColMajor> eigen_vec;

    // effective computation of eigenvalues and eigenvectors    
    GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);    
  }

\endprecode

<p> Classes DenseEigenProblem, SparseEigenProblem and MatrixFreeEigenProblem are deriving from
 base class EigenProblem_Base, and are overloading some methods of this base class. Therefore
 if you need to define a new class of eigenproblems, it could be a good idea to write a derived class.
 In order to help you out, we have detailed all the methods of EigenProblem_Base : </p>

<table class="category-table">
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#Init"> Init </a></td>
<td class="category-table-td"> Initialization of the eigenvalue problem </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#InitMatrix"> InitMatrix </a></td>
<td class="category-table-td"> Stiffness matrix (and optionall mass matrix) is given  </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetComputationalMode"> GetComputationalMode </a></td>
<td class="category-table-td"> Returns the computational mode used (regular, shifted, ...) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetComputationalMode"> SetComputationalMode </a></td>
<td class="category-table-td"> Sets the computational mode used (regular, shifted, ...) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbAskedEigenvalues"> GetNbAskedEigenvalues </a></td>
<td class="category-table-td"> Returns the number of wanted eigenvalues </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbAskedEigenvalues"> SetNbAskedEigenvalues </a></td>
<td class="category-table-td"> Sets the number of wanted eigenvalues </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetTypeSpectrum"> GetTypeSpectrum </a></td>
<td class="category-table-td"> Returns the type of spectrum wanted by the user </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetTypeSpectrum"> SetTypeSpectrum </a></td>
<td class="category-table-td"> Sets the of spectrum wanted by the user </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetTypeSorting"> GetTypeSorting </a></td>
<td class="category-table-td"> Returns how eigenvalues are sorted (real part, modulus, etc) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetShiftValue"> GetShiftValue </a></td>
<td class="category-table-td"> Returns the shift </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetShiftValue"> GetImagShiftValue </a></td>
<td class="category-table-td"> Returns imaginary part of the shift (real unsymmetric problem) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetCholeskyFactoForMass"> SetCholeskyFactoForMass </a></td>
<td class="category-table-td"> Tells to find eigenvalues of L<sup>-1</sup> K L<sup>-T</sup> if M = L L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetCholeskyFactoForMass"> UseCholeskyFactoForMass </a></td>
<td class="category-table-td"> Returns true if eigenvalues of L<sup>-1</sup> K L<sup>-T</sup>are searched (M = L L<sup>T</sup>) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetDiagonalMass"> SetDiagonalMass </a></td>
<td class="category-table-td"> Tells to find eigenvalues of M<sup>-1/2</sup> K M<sup>-1/2</sup>are searched (M diagonal) </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#DiagonalMass"> DiagonalMass </a></td>
<td class="category-table-td"> Returns true if eigenvalues of M<sup>-1/2</sup> K M<sup>-1/2</sup>are searched (M diagonal) </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetStoppingCriterion"> SetStoppingCriterion </a></td>
<td class="category-table-td"> Sets the stopping criterion used by iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetStoppingCriterion"> GetStoppingCriterion </a></td>
<td class="category-table-td"> Returns the stopping criterion used by iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetNbMaximumIterations"> SetNbMaximumIterations </a></td>
<td class="category-table-td"> Sets the maximum number of iterations allowed for the iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SetNbMaximumIterations"> GetNbMaximumIterations </a></td>
<td class="category-table-td"> Returns the maximum number of iterations allowed for the iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbMatrixVectorProducts"> GetNbMatrixVectorProducts </a></td>
<td class="category-table-td"> Returns the number of iterations performed by the iterative process </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetNbArnoldiVectors"> GetNbArnoldiVectors </a></td>
<td class="category-table-td"> Returns the number of Arnoldi vectors </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetNbArnoldiVectors"> SetNbArnoldiVectors </a></td>
<td class="category-table-td"> Sets the number of Arnoldi vectors </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetM"> GetM </a></td>
<td class="category-table-td"> Returns the number of rows of the stiffness matrix </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#GetM"> GetN </a></td>
<td class="category-table-td"> Returns the number of columns of the stiffness matrix </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#GetPrintLevel"> GetPrintLevel </a></td>
<td class="category-table-td"> Returns the print level </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#SetPrintLevel"> SetPrintLevel </a></td>
<td class="category-table-td"> Sets the print level </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#IncrementProdMatVect"> IncrementProdMatVect </a></td>
<td class="category-table-td"> Increments the number of iterations performed by the iterative process </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#PrintErrorInit"> PrintErrorInit </a></td>
<td class="category-table-td"> Prints an error message if InitMatrix has not been called </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#IsSymmetricProblem"> IsSymmetricProblem </a></td>
<td class="category-table-td"> Returns true if the stiffness matrix is symmetric </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#FactorizeDiagonalMass"> FactorizeDiagonalMass </a></td>
<td class="category-table-td"> Computation of M<sup>1/2</sup>, once M is known </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#MltSqrtDiagonalMass"> MltInvSqrtDiagonalMass </a></td>
<td class="category-table-td"> Multiplication by M<sup>-1/2</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltSqrtDiagonalMass"> MltSqrtDiagonalMass </a></td>
<td class="category-table-td"> Multiplication by M<sup>1/2</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeDiagonalMass"> ComputeDiagonalMass </a></td>
<td class="category-table-td"> Computation of diagonal of M </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeMassForCholesky"> ComputeMassForCholesky </a></td>
<td class="category-table-td"> Multiplication by M<sup>-1/2</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeMassMatrix"> ComputeMassMatrix </a></td>
<td class="category-table-td"> Computation of mass matrix M </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltMass"> MltMass </a></td>
<td class="category-table-td"> Multiplication by mass matrix M </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeStiffnessMatrix"> ComputeStiffnessMatrix </a></td>
<td class="category-table-td"> Computation of stiffness matrix K </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltStiffness"> MltStiffness </a></td>
<td class="category-table-td"> Multiplication by stiffness matrix K </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#ComputeAndFactorizeStiffnessMatrix"> ComputeAndFactorizeStiffnessMatrix </a></td>
<td class="category-table-td"> Computation and factorization of a M + b K </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#ComputeSolution"> ComputeSolution </a></td>
<td class="category-table-td"> Computation and factorization of a M + b K </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#FactorizeCholeskyMass"> FactorizeCholeskyMass </a></td>
<td class="category-table-td"> Computation of Cholesky factor L of mass matrix (M = L L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#MltCholeskyMass"> MltCholeskyMass </a></td>
<td class="category-table-td"> Multiplication by L or L<sup>T</sup> </td> </tr>
<tr class="category-table-tr-1">
<td class="category-table-td"> <a href="#SolveCholeskyMass"> SolveCholeskyMass </a></td>
<td class="category-table-td"> Resolution of L x = b or L<sup>T</sup> x = b </td> </tr>
<tr class="category-table-tr-2">
<td class="category-table-td"> <a href="#Clear"> Clear </a></td>
<td class="category-table-td"> Clears memory used by factorizations (if any present)</td> </tr>
</table>

<p> The choice of eigensolver is made when calling function <a href="#GetEigenvaluesEigenvectors">GetEigenvaluesEigenvectors</a> by providing an optional argument. If this argument is not provided, default eigenvalue solver will be used (Arpack). </p>

<p><br/> <br/></p>



<div class="separator"><a name="Init"></a></div>



<h3>Init</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void Init(int n);
</pre>


<p>This method is actually called by each eigenvalue solver before starting the research of eigenvalues.
 For example, it resets the number of iterations. This method should not be overloaded, neither called by the user. </p>


<h4>Location :</h4>
<p>EigenvalueSolver.cxx</p>



<div class="separator"><a name="InitMatrix"></a></div>



<h3>InitMatrix</h3>


<h4>Syntax :</h4>
 <pre class="syntax-box">
  void InitMatrix(Matrix& K);
  void InitMatrix(Matrix& K, Matrix& M);
</pre>


<p>This method allows the initialization of pointers for the stiffness matrix and mass matrix.
 It is mandatory to call it when using SparseEigenProblem, DenseEigenProblem or MatrixFreeEigenProblem. </p>

<h4>Example :</h4>
\precode

{

// declaration of the eigenproblem
DenseEigenProblem<double, General, RowMajor> var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, RowMajor> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// for a generalized eigenvalue problem, provide M
Matrix<double, Symmetric, RowSymPacked> M(n, n);
M.SetIdentity();
// searching K x = lambda M x
var_eig.InitMatrix(K, M);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// if the type of M is different from Matrix<double, Symmetric, RowSymPacked>
// and is Matrix<Tm, PropM, StorageM>
// use DenseEigenProblem<double, General, RowMajor, Tm, PropM, StorageM> var_eig;
}

{
// for a sparse eigenproblem, similar stuff
// declaration of the eigenproblem
SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse> > var_eig;
Vector<double> eigen_values, eigen_imag;
Matrix<double> eigen_vec;

// you can set some parameters
var_eig.SetNbAskedEigenvalues(5);
var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);

// then you can construct the stiffness matrix
int n = 20;
Matrix<double, General, ArrayRowSparse> K(n, n);
K.FillRand();

// and you provide this matrix to the eigenproblem
// standard eigenvalue problem K x = lambda x
var_eig.InitMatrix(K);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// for a generalized eigenvalue problem, provide M
Matrix<double, Symmetric, ArrayRowSymSparse> M(n, n);
M.SetIdentity();
// searching K x = lambda M x
var_eig.InitMatrix(K, M);

// then you can call GetEigenvaluesEigenvectors
GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

// if the type of M is different from Matrix<double, Symmetric, ArrayRowSymSparse>
// and is Matrix<Tm, PropM, StorageM>
// use SparseEigenProblem<double, Matrix<double, General, ArrayRowSparse>,
//                                Matrix<Tm, PropM, StorageM> > var_eig;
}

{
  // matrix-free eigenproblem
  // stiffness matrix has type MyMatrixClass
  MatrixFreeEigenProblem<double, MyMatrixClass> var_eig;

  // you can set some parameters
  var_eig.SetNbAskedEigenvalues(5);
  var_eig.SetComputationalMode(var_eig.REGULAR_MODE);
  var_eig.SetSpectrum(var_eig.LARGE_EIGENVALUES, 0);
 
  // then you can construct the stiffness matrix
  MyMatrixClass K;

  // and you provide this matrix to the eigenproblem
  // standard eigenvalue problem K x = lambda x
  var_eig.InitMatrix(K);

  // then you can call GetEigenvaluesEigenvectors
  GetEigenvaluesEigenvectors(var_eig, lambda, lambda_imag, eigen_vec);

  // no generalized problem for MatrixFreeEigenProblem
}


\endprecode

<h4>Location :</h4>
<p>EigenvalueSolver.cxx</p>


*/
